### HTTP缓存

1. 使用缓存的优点
   * 缓存减少了冗余的数据传输
   * 能够更快地加载网页
   * 降低了对原始服务器的要求。服务器可以更快地响应，避免过载
   * 降低了距离时延

2. 缓存的类型
   1. 强缓存
      * Cache-Control （相对时间）
      * Expires （绝对时间）
   2. 协商缓存
      * Etag / If-None-Match （资源标识符）
      * Last-Modified / If-Modified-Since （资源最后修改的时间）

![缓存](.\imgs\缓存.png)

### 持久化连接

1. HTTP/1.0+ keep-alive

   ~~~js
   Connection: Keep-alive
   Keep-Alive: max=5, timeout=120
   // 服务器最多还会为另外5个事务保持连接打开的状态，或者将连接打开的状态保持到连接空闲了2分钟以后
   ~~~

   Keep-Alive需要主动发起

   Keep-Alive首部只是请求将连接保持在活跃状态，服务器或客户端并不一定同意进行Keep-Alive会话。它们可以在任意时刻关闭Keep-Alive会话，并可以随意限制Keep-Alive连接所处理事务的数量。

   Keep-Alive和哑代理（盲中继）：一些老的代理不知道Keep-Alive是什么意思，只是沿着转发链路将报文一字不漏地传给服务器，于是就会出现问题。

2. HTTP/1.1 persistent

   HTTP/1.1持久型连接在默认情况下是激活的，如果需要关闭持久连接，需要显示地添加一个Connection: close首部。

   HTTP/1.1允许在持久连接上可选地使用请求管道，当第一条请求到达服务器端时，第二条第三条请求也可以开始发送了。

   管道化连接地限制：必须是持久连接，必须按照相同的顺序回送HTTP响应（HTTP报文中没有序列化标签），客户端必须做好连接会在任意时刻关闭的准备来重发所有未完成的管道化请求，不能通过管道化连接发送POST之类的非幂等请求

   ![持久化连接](.\imgs\持久化连接.png)

### HTTP/2

1. HTTP/1.1 存在的问题

   1. 队头阻塞（Head-Of-Line Blocking)

      解决方案：域名切片；合并js文件，雪碧图，内联图片

   2. HTTP请求首部信息内容过大且内容大都重复

2. HTTP/2特性

   * 二进制分帧，head frame & data frame
   * 多路复用，可以在一条tcp通道上同时发送多个请求，不用按照顺序且非阻塞，先响应的先回来。
   * 首部压缩
     1. 使用hpack压缩格式来压缩请求和响应标头元数据再传输以减小体积
     2. 在客户端和服务器端维护一张标头字段的索引列表
   * 服务端推送，客户端无需请求，服务端主动将一些资源推送给客户端缓存

### HTTP/3



